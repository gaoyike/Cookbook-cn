[[Squeryl]]
使用Record和Squeryl的关联性数据库
-------------------------------

Squeryl是一个对象关联的库类. 他转化Scala的类到一个关联性数据库的表, 行和列, 并且提供一个方法来表达SQL语句通过使用Scala的编译器. Lift Squeryl Record模型集成了Squeryl和Record. 这意味着你的Lift应用可以使用Scala来加载和储存数据.并且, 你也可以使用Record的一些功能, 比如说一个数据的验证.

这章的数据可以在以下的地址找到: https://github.com/LiftCookbook/cookbook_squeryl[https://github.com/LiftCookbook/cookbook_squeryl].

[[ConfiguringSqueryl]]
设置Squeryl和Record
~~~~~~~~~~~~~~~~~~

Problem
^^^^^^^

你想设置你的Lift应用使用Squeryl和Record.

Solution
^^^^^^^^

在你的构建文件中包含Squeryl-Record依赖库, 并且在 `Boot.scala`中提供一个数据库连接到 `SquerylRecord.initWithSquerylSession`.

比如说, 设置Squeryl和PostgreSQL, 修改 `build.sbt` 文件, 添加两个依赖库, 一个是Squeryl-Record, 另一个是数据库的驱动:

[source, scala]
---------------------------------------------------------------
libraryDependencies ++= {
  val liftVersion = "2.5-RC2"
  Seq(
    "net.liftweb" %% "lift-webkit" % liftVersion,
    "net.liftweb" %% "lift-squeryl-record" % liftVersion,
    "postgresql" % "postgresql" % "9.1-901.jdbc4"
    ...
    )
}
---------------------------------------------------------------

这个会给你一个访问到Squeryl版本为: 0.9.5-6.

在 `Boot.scala` 中, 我们定义了一个连接并且注册它到Squeryl:

[source, scala]
---------------------------------------------------------------
Class.forName("org.postgresql.Driver")

def connection = DriverManager.getConnection(
  "jdbc:postgresql://localhost/mydb",
  "username", "password")

SquerylRecord.initWithSquerylSession(
  Session.create(connection, new PostgreSqlAdapter) )

---------------------------------------------------------------

所有的Squeryl语句需要作为一个transaction的内容才能运行. 一个方法是提供一个transaction的设置到所有的HTTP请求. 这也需要在 `Boot.scala` 中设置:

[source, scala]
---------------------------------------------------------------
S.addAround(new LoanWrapper {
  override def apply[T](f: => T): T = inTransaction { f }
})
---------------------------------------------------------------


Discussion
^^^^^^^^^^

你可以使用任何的JVM表达层机制在Lift中. Lift Record提供的是一个轻量级的接口, 它包含着表达层上的Lift的CSS转化, 界面和插件. Squeryl-Record是一个具体的, Record和Squeryl的实现. 这意味着你可以使用标准的Record对象和结构. 通过使用Squeryl, 你写的语句可以在编译的时候被校验.

作为插件插入Squeryl意味着初始化Squeryl的会话管理系统. 它允许我们包裹一个一句在Squeryl的 `transaction` 和 `inTranscation` 方法中. 它们之间的区别是, `inTranscation` 会开启一个新的transaction, 如果你请求的transaction不存在. 然而 `transaction` 会永远建立一个新的transaction.

为了区别一个transaction是对于所有的HTTP请求可用的, 我们使用 `addARound`, 我们可以写一些语句在Lift中, 并且在大部分不建立一个新的transaction, 除非我们希望它建立. 比如说:

[source,scala]
------------------------------------------------------------
import net.liftweb.squerylrecord.RecordTypeMode._
val r = myTable.insert(MyRecord.createRecord.myField(aValue))
------------------------------------------------------------

在这章中, 我们使用的是 `PostgreSqlAdapter` . Squeryl也支持 `OracleAdapter`, `MySQLInnoDBAdapter` 和 `MySQLAdapter`, `MSSQLServer`, `H2Adapter`, `DB2Adapter` 和 `DerbyAdapter`.


See Also
^^^^^^^^

Squeryl的 _Getting Started Guide_ 介绍了更多关于会话管理和设置: http://squeryl.org/getting-started.html[http://squeryl.org/getting-started.html].

请看 <<SquerylJNDI>> , 关于设置一个 Java Naming and Directory Interface (JNDI).



[[SquerylJNDI]]
使用一个 JNDI 数据库
~~~~~~~~~~~~~~~~~~

Problem
^^^^^^^

你想使用一个JNDI数据源到你的Squeryl-Record Lift应用.

Solution
^^^^^^^^

在 `Boot.scala` 调用 `initWithSquerylSession` 通过使用 `DataSource` 来查找JDNI内容:

[source,scala]
------------------------------------------------------------
import javax.sql.DataSource
val ds = new InitialContext().
  lookup("java:comp/env/jdbc/mydb").asInstanceOf[DataSource]

SquerylRecord.initWithSquerylSession(
  Session.create(ds.getConnection(), new MySQLAdapter) )
------------------------------------------------------------

...替换 `mydb` 为你的JNDI数据库名称, 并且替换 `MySQLAdapter` 为适当的数据库适配器.

Discussion
^^^^^^^^^^

JNDI是一个容器的服务, 它允许你设置一个数据库连接在容器上, 并且引用它在你的应用中. 使用它的优势是, 你可以避免包含一个数据库密码在你的Lift应用上.

JNDI的设置对于每个容器是不同的, 并且对于各个版本也是不同的. _See Also_ 包含了所有流行的容器上的设置方法.

一些环境也许要求你包含你的JNDI源在你的 `src/main/webapp/WEB-INF/web.xml` 文件:

[source,xml]
------------------------------------------
<resource-ref>
 <res-ref-name>jdbc/mydb</res-ref-name>
 <res-type>javax.sql.DataSource</res-type>
 <res-auth>Container</res-auth>
</resource-ref>
------------------------------------------


See Also
^^^^^^^^

一些JDNI设置的资源:

* 一个Lift WIki上的例子, 关于Apache和Jetty的设置:http://www.assembla.com/spaces/liftweb/wiki/Apache_and_Jetty_Configuration[http://www.assembla.com/spaces/liftweb/wiki/Apache_and_Jetty_Configuration].

* Jetty上的不同环境下的设置: http://www.eclipse.org/jetty/documentation/current/jndi-datasource-examples.html[http://www.eclipse.org/jetty/documentation/current/jndi-datasource-examples.html].

* Tomcat上的JDNI设置: http://tomcat.apache.org/tomcat-7.0-doc/jndi-resources-howto.html#JDBC_Data_Sources[http://tomcat.apache.org/tomcat-7.0-doc/jndi-resources-howto.html#JDBC_Data_Sources].


[[SquerylOneToMany]]
一对多的关系
~~~~~~~~~~

Problem
^^^^^^^

你想建立一个一对多的关系, 比如说一个卫星属于一个单一的星球, 但是一个星球可能有多于一个的卫星.

Solution
^^^^^^^^

使用Squeryl的 `oneToManyRelation` 在你的代码中, 并且在你的Lift模型上包含一个引用从卫星到星球.

我们的目标是设置一个关系模型就像 <<SquerylPlanetOneToManyFigure>>.

[[SquerylPlanetOneToManyFigure]]
.一个星球可能有很多卫星, 但是一个卫星观测器只属于一个星球.
image::images/planets.png[width=640]

代码是:

[source, scala]
-----------------------------------------------------------
package code.model

import org.squeryl.Schema
import net.liftweb.record.{MetaRecord, Record}
import net.liftweb.squerylrecord.KeyedRecord
import net.liftweb.record.field.{StringField, LongField}
import net.liftweb.squerylrecord.RecordTypeMode._

object MySchema extends Schema {

  val planets = table[Planet]
  val satellites = table[Satellite]

  val planetToSatellites = oneToManyRelation(planets, satellites).
    via((p,s) => p.id === s.planetId)

  on(satellites) { s =>
    declare(s.planetId defineAs indexed("planet_idx"))
  }

  class Planet extends Record[Planet] with KeyedRecord[Long] {
    override def meta = Planet
    override val idField = new LongField(this)
    val name = new StringField(this, 256)
    lazy val satellites = MySchema.planetToSatellites.left(this)
  }

  object Planet extends Planet with MetaRecord[Planet]

  class Satellite extends Record[Satellite] with KeyedRecord[Long] {
     override def meta = Satellite
     override val idField = new LongField(this)
     val name = new StringField(this, 256)
     val planetId = new LongField(this)
     lazy val planet = MySchema.planetToSatellites.right(this)
  }

  object Satellite extends Satellite with MetaRecord[Satellite]

}
-----------------------------------------------------------

上面的代码定义了两个表基于Record的类, 它们是 `table[Planet]` 和 `table[Satellite]`. 它建立了一个 `oneToManyRelation`  基于 (`via`)  `planetId` 在卫星的表中.

它给Squeryl了关于如何建立一个foreign key来约束 `planetId` 到一个现存的星球表中的引用. 可以通过查看Squeryl中自动生成的机制, 来观察它:

[source, sql]
-----------------------------------------------------------
-- table declarations :
create table Planet (
    name varchar(256) not null,
    idField bigint not null primary key auto_increment
  );
create table Satellite (
    name varchar(256) not null,
    idField bigint not null primary key auto_increment,
    planetId bigint not null
  );
-- indexes on Satellite
create index planet_idx on Satellite (planetId);
-- foreign key constraints :
alter table Satellite add constraint SatelliteFK1 foreign key (planetId)
  references Planet(idField);
-----------------------------------------------------------

一个名为 `planet_idx` 的检索, 声明在 `planetId` 上, 增强语句的joins效率.

最后, 我们通过使用 `planetToSatellites.left` 和 `right` 来建立一个查找语句作为 `Planet.satellites` 和 `Satellite.planet`.  我们可以声明它们, 通过插入示例数据并且运行这些语句:

[source, scala]
-----------------------------------------------------------
inTransaction {
  code.model.MySchema.create

  import code.model.MySchema._

  val earth = planets.insert(Planet.createRecord.name("Earth"))
  val mars = planets.insert(Planet.createRecord.name("Mars"))

  // .save as a short-hand for satellite.insert when we don't need
  // to immediately reference the record (save returns Unit).
  Satellite.createRecord.name("The Moon").planetId(earth.idField.is).save
  Satellite.createRecord.name("Phobos").planetId(mars.idField.is).save

  val deimos = satellites.insert(
    Satellite.createRecord.name("Deimos").planetId(mars.idField.is) )

  println("Deimos orbits: "+deimos.planet.single.name.is)
  println("Moons of Mars are: "+mars.satellites.map(_.name.is))

}
-----------------------------------------------------------

运行这个代码, 会产生以下输出:

-----------------------------------------------------------
Deimos orbits: Mars
Moons of Mars are: List(Phobos, Deimos)
-----------------------------------------------------------

在这个例子中, 我们调用 `deimos.planet.single` 将会返回一个结果, 或者, 如果没有找到相关的数据, 会返回一个异常. `headOption` 是一个更安全的方法, 如果相关的数据没有被找到, 它会返回一个 `None` 或者 `Some[Planet]`.



Discussion
^^^^^^^^^^

方法 `planetToSatellites.left` 不是一个简单的 `Satellite` 对象的集合. 它是一个Squeryl `Query[Satellite]`, 这意味着你可以把它看做其他类型的 `Queryable[Satellite]`. 比如说, 我们可以请求一个星球上所有的卫星, 其中包含字母在"E"以后, 比如说对于 Mars 会是 "Phobos":

[source, scala]
-----------------------------------------------------------
mars.satellites.where(s => s.name gt "E").map(_.name)
-----------------------------------------------------------

方法 `left` 会返回一个 `OneToMany[Satellite]`, 它会添加以下的方法:

* `assign` -- 添加一个新的关系, 但是不会更新数据库.
* `associate` -- 它像 `assign` 一样, 不过更新数据库.
* `deleteAll` -- 删除关系.

方法 `assign` 给卫星一个到星球的关系:

[source, scala]
-----------------------------------------------------------
val express = Satellite.createRecord.name("Mars Express")
mars.satellites.assign(express)
express.save
-----------------------------------------------------------

下次, 当我们调用 `mars.satellites` 我们会找到mars的卫星.

一个 `associate` 调用会进一步的帮我们自动的插入和更新卫星:

[source, scala]
-----------------------------------------------------------
val express = Satellite.createRecord.name("Mars Express")
mars.satellites.associate(express)
-----------------------------------------------------------

第三个方法, `deleteAll` 就像它的名字一样. 它会执行以下代码, 并且返回很多被删除的行:

[source, sql]
-----------------------------------------------------------
delete from Satellite
-----------------------------------------------------------

一对多关系的右边也可以添加额外的方法, 通过添加`ManyToOne[Planet]` 到 `assign` 和 `delete`.  请注意, 当你删除一对多关系的`一`的那边的时候, 任何相关的另一边数据关系必需提前被删除, 这是为了防止一个数据库的错误, 比如说, 一些没有星球的卫星.

作为 `left` 和 `right` 是语句, 这意味着, 每次你调用它们的时候, 你都发送一个新的语句到数据库.  Squeryl引用了这个格式 _stateless relations_.

_stateful_ 版本的 `left` 和 `right` 是这样:

[source, scala]
-----------------------------------------------------------
class Planet extends Record[Planet] with KeyedRecord[Long] {
 ...
 lazy val satellites : StatefulOneToMany[Satellite] =
   MySchema.planetToSatellites.leftStateful(this)
}

class Satellite extends Record[Satellite] with KeyedRecord[Long] {
  ...
  lazy val planet : StatefulManyToOne[Planet] =
    MySchema.planetToSatellites.rightStateful(this)
}
-----------------------------------------------------------

这个改变意味着, `mars.satellites` 的结果将被缓存. 以后关于这个 `Planet` 的实例的调用将不会出发一个重新的数据库调用. 你仍然可以使用 `associate` 建立一个新的关系, 或使用 `deleteAll` , 它们都和你想要的结果是一样的, 但是一个数据在其他地方被改变的时候, 你需要通过使用 `refresh` 在现有的关系上, 来查看更新的结果.

你应该使用哪个版本? 这取决于你的应用, 但是你可以同时使用它们在同一个record中.


See Also
^^^^^^^^

Squeryl关系在以下地址有文档: http://squeryl.org/relations.html[http://squeryl.org/relations.html].





[[SquerylManyToMany]]
多对多关系
~~~~~~~~

Problem
^^^^^^^

你想建立一个多对多的关系, 比如说一个星球可以被许多的空间探测器访问, 但是一个空间探测器可以访问许多的星球.

Solution
^^^^^^^^

使用 Squeryl的 `manyToManyRelation` 在你的机制中, 并且建立一个record来保持的两边的join的关系. <<SquerylPlanetManyToManyFigure>> 中有我们这章中建的结构, 其中 `Visit` 是一个record, 它用来连接一个many到另一个many.

[[SquerylPlanetManyToManyFigure]]
.Many-to-many: Jupiter被Juno 和 Voyager 1访问; Saturn 被 Voyager访问.
image::images/visits.png[width=640]

这个机制被定义在两个表中, 一个在星球中, 一个在探测器中, 并且还有一个record名为 `Visit`, 它保持着两边的关系:

[source, scala]
-----------------------------------------------------------
package code.model

import org.squeryl.Schema
import net.liftweb.record.{MetaRecord, Record}
import net.liftweb.squerylrecord.KeyedRecord
import net.liftweb.record.field.{IntField, StringField, LongField}
import net.liftweb.squerylrecord.RecordTypeMode._
import org.squeryl.dsl.ManyToMany

object MySchema extends Schema {

  val planets = table[Planet]
  val probes = table[Probe]

  val probeVisits = manyToManyRelation(probes, planets).via[Visit] {
    (probe, planet, visit) =>
      (visit.probeId === probe.id, visit.planetId === planet.id)
  }

  class Planet extends Record[Planet] with KeyedRecord[Long] {
    override def meta = Planet
    override val idField = new LongField(this)
    val name = new StringField(this, 256)
    lazy val probes : ManyToMany[Probe,Visit] =
      MySchema.probeVisits.right(this)
  }

  object Planet extends Planet with MetaRecord[Planet]

  class Probe extends Record[Probe] with KeyedRecord[Long] {
    override def meta = Probe
    override val idField = new LongField(this)
    val name = new StringField(this, 256)
    lazy val planets : ManyToMany[Planet,Visit] =
      MySchema.probeVisits.left(this)
  }

  object Probe extends Probe with MetaRecord[Probe]

  class Visit extends Record[Visit] with KeyedRecord[Long] {
    override def meta = Visit
    override val idField = new LongField(this)
    val planetId = new LongField(this)
    val probeId = new LongField(this)
  }

  object Visit extends Visit with MetaRecord[Visit]
}
-----------------------------------------------------------

在 `Boot.scala` 我们可以把这种关系显示出来...

[source, scala]
-----------------------------------------------------------
inTransaction {
  code.model.MySchema.printDdl
}
-----------------------------------------------------------

...以上代码会显示以下结果, 但是根据版本不同, 也许会有不同:

[source, sql]
-----------------------------------------------------------
-- table declarations :
create table Planet (
    name varchar(256) not null,
    idField bigint not null primary key auto_increment
  );
create table Probe (
    name varchar(256) not null,
    idField bigint not null primary key auto_increment
  );
create table Visit (
    idField bigint not null primary key auto_increment,
    planetId bigint not null,
    probeId bigint not null
  );
-- foreign key constraints :
alter table Visit add constraint VisitFK1 foreign key (probeId)
  references Probe(idField);
alter table Visit add constraint VisitFK2 foreign key (planetId)
  references Planet(idField);
-----------------------------------------------------------

请注意 `visit` 表中将会保留所有的 `planetId` 和 `probeId` 的每一个行的关系.

`Planet.probes` 和 `Probe.planets` 提供了一个 `associate` 方法来建立一个新的关系. 比如说, 我们可以建立一个星球和探测器的集合...

[source, scala]
-----------------------------------------------------------
val jupiter = planets.insert(Planet.createRecord.name("Jupiter"))
val saturn = planets.insert(Planet.createRecord.name("Saturn"))
val juno = probes.insert(Probe.createRecord.name("Juno"))
val voyager1 = probes.insert(Probe.createRecord.name("Voyager 1"))
-----------------------------------------------------------

...并且让它们互相连接:

[source, scala]
-----------------------------------------------------------
juno.planets.associate(jupiter)
voyager1.planets.associate(jupiter)
voyager1.planets.associate(saturn)
-----------------------------------------------------------

我们也可以使用 `Probe.planets` 和 `Planet.probes` 作为一个语句来查找关联. 为了在一个代码片段中访问所有访问每个星球的探测器, 我们可以这样写:

[source, scala]
-----------------------------------------------------------
package code.snippet

class ManyToManySnippet {
  def render =
    "#planet-visits" #> planets.map { planet =>
      ".planet-name *" #> planet.name.is &
      ".probe-name *" #> planet.probes.map(_.name.is)
    }
}
-----------------------------------------------------------

这个代码片段可以和一个模板这样组合:

[source, html]
-----------------------------------------------------------
<div data-lift="ManyToManySnippet">
  <h1>Planet facts</h1>
  <div id="planet-visits">
    <p>
      <span class="planet-name">Name will be here</span> was visited by:
    </p>
    <ul>
      <li class="probe-name">Probe name goes here</li>
    </ul>
  </div>
</div>
-----------------------------------------------------------

上半部分在 <<SquerylManyToManyScreengrab>> 中给出了一个这个模板和代码输出的例子.

Discussion
^^^^^^^^^^

SquerylDSL `manyToManyRelation(probes, planets).via[Visit]` 是一个核心的元素连接我们的 `Planet`, `Probe` 和 `Visit` 到一起.它允许访问 "left" 和 "right" 在我们的 `Probe.planets` 和 `Planet.probes`.

就像 <<SquerylOneToMany>> 中的一对多关系, 左边和右边都是语句. 当你请求一个 `Planet.probes` 数据库执行一个语句, 并且访问join在 `Visit` records中:

[source, sql]
-----------------------------------------------------------
Select
  Probe.name,
  Probe.idField
From
  Visit,
  Probe
Where
  (Visit.probeId = Probe.idField) and (Visit.planetId = ?)
-----------------------------------------------------------

就像 <<SquerylOneToMany>> 中提到的, 有一种stateful的 `left` 和 `right` 可以缓存对象.

在我们插入到数据的数据中, 我们不是一定要声明 `Visit`. Squeryl `manyToManyRelation` 有足够的信息来插入一次访问作为一个关系. 顺便提一下, 在多对多的关系中, 我们使用哪个方向来调用关系, 是无所谓的. 以下两个表达式是一样的, 并且结果是一样的:

[source, scala]
-----------------------------------------------------------
juno.planets.associate(jupiter)
// ..or..
jupiter.probes.associate(juno)
-----------------------------------------------------------

你也许会质疑, 为什么我们需要一个 `Visit` record, 因为它有很多优点. 比如说, 你可以附加额外的信息到join表中, 比如说探测器访问一个星球的年份.

为了实现它, 我们修改表Visit来添加一个额外的信息:

[source, scala]
-----------------------------------------------------------
class Visit extends Record[Visit] with KeyedRecord[Long] {
  override def meta = Visit
  override val idField = new LongField(this)
  val planetId = new LongField(this)
  val probeId = new LongField(this)
  val year = new IntField(this)
}
-----------------------------------------------------------

`Visit` 仍然是一个 `planetId` 和 `probeId` 引用的容器, 但是在这里, 我们添加了一个整数的变量来表达访问的年份.

为了记录访问的年份, 我们需要 `assign` 方法提供一个 `ManyToMany[T]`.  这将会建立一个关系, 但是不会改变数据库. 并且, 它会返回一个 `Visit` 实例, 我们可以修改并且保存它到数据库:

[source, scala]
-----------------------------------------------------------
probeVisits.insert(voyager1.planets.assign(saturn).year(1980))
-----------------------------------------------------------

`assign` 方法的返回类型在这里是 `Visit`, 并且 `Visit` 有一个 `year` 域. 插入 `Visit` record 通过使用 `probeVisits` 会在数据库中建立一个新的行.


为了访问这个额外的信息在 `Visit` 对象, 你可以使用 `ManyToMany[T]` 提供的几个方法:

* `associations` -- 一个语句, 返回关于 `Planet.probes` 或者 `Probe.planets`的  `Visit` 对象, .

* `associationMap` -- 一个语句返回一对 `(Planet,Visit)` 或者 `(Probe,Visit)`, 取决于你在那边调用这个方法 (probes 或者 planets).

比如说, 在一个代码片段中, 我们可以列出所有的空间探测器, 并且对于每一个探测器, 我们显示它访问的星球和访问星球的时间, 这个代码如下:

[source, scala]
-----------------------------------------------------------
"#probe-visits" #> probes.map { probe =>
  ".probe-name *" #> probe.name.is &
  ".visit" #> probe.planets.associationMap.collect {
    case (planet, visit) =>
      ".planet-name *" #> planet.name.is &
      ".year" #> visit.year.is
    }
}
-----------------------------------------------------------

我们使用 `collect` 而不是 `map` 是为了匹配 `(Planet,Visit)` tuple 并且给值一个有意义的名字. 你也可以使用 `(for { (planet, visit) <- probe.planets.associationMap } yield ...)` .

下半部的 <<SquerylManyToManyScreengrab>> 介绍了如何使以上代码和以下模板结合:

[source, html]
-----------------------------------------------------------
<h1>Probe facts</h1>

<div id="probe-visits">
  <p><span class="probe-name">Space craft name</span> visited:</p>
  <ul>
    <li class="visit">
      <span class="planet-name">Name here</span> in <span class="year">n</span>
    </li>
  </ul>
</div>
-----------------------------------------------------------

[[SquerylManyToManyScreengrab]]
.以上使用多对多关系的例子的输出.
image::images/visitsscreengrab.png[width=640]

为了删除一个关系, 你需要访问 `dissociate` 和 `dissociateAll` 在 `left` 和 `right` 语句.  为了删除一个单一的关系:


[source, scala]
-----------------------------------------------------------
val numRowsChanged = juno.planets.dissociate(jupiter)
-----------------------------------------------------------

以上代码在SQL中为:

[source, sql]
-----------------------------------------------------------
delete from Visit
where
  probeId = ? and planetId = ?
-----------------------------------------------------------

为了删除所有的关系:


[source, scala]
-----------------------------------------------------------
val numRowsChanged = jupiter.probes.dissociateAll
-----------------------------------------------------------

以上代码在SQL为:

[source, sql]
-----------------------------------------------------------
delete from Visit
where
  Visit.planetId = ?
-----------------------------------------------------------

如果你想删除的record在 `Visit` 中有没有删除的关系, 你是不能直接删除 `Planet` 或者 `Probe`的. 如果你删除它, 你会得到一个异常. 所以你需要先使用 `dissociatateAll` :

[source, scala]
-----------------------------------------------------------
jupiter.probes.dissociateAll
planets.delete(jupiter.id)
-----------------------------------------------------------

然而, 如果你想 _cascading deletes_ 你可以实现它, 通过重写默认的机制:

[source, scala]
-----------------------------------------------------------
// To automatically remove probes when we remove planets:
probeVisits.rightForeignKeyDeclaration.constrainReference(onDelete cascade)

// To automatically remove planets when we remove probes:
probeVisits.leftForeignKeyDeclaration.constrainReference(onDelete cascade)
-----------------------------------------------------------

以上是部分的默认机制, 通过修改它, 将会改变表的限制, 使用 `printDdl` 来实现它 (取决于你的数据库):

[source, sql]
-----------------------------------------------------------
alter table Visit add constraint VisitFK1 foreign key (probeId)
  references Probe(idField) on delete cascade;

alter table Visit add constraint VisitFK2 foreign key (planetId)
  references Planet(idField) on delete cascade;
-----------------------------------------------------------

See Also
^^^^^^^^

<<SquerylOneToMany>>, 在一对多关系上介绍了 `leftStateful` 和 `rightStateful` 关系, 这也适用于多对多关系.

Foreign keys, cascading deletes, 介绍在: http://squeryl.org/relations.html[http://squeryl.org/relations.html].





[[FieldValidation]]
对一个域添加一个校验
~~~~~~~~~~~~~~~~~~~

Problem
^^^^^^^

你想在你的模型下添加一个域的校验信息, 它可以确保用户不会忘记填写信息或者填写一些错误的信息.

Solution
^^^^^^^^

重写方法 `validations` 在你的域上, 并且提供多个校验方程.

作为一个例子, 假设我们有一个存储星球的数据库, 并且我们想确保用户输入的任何新的星球包含至少五个字母. 我们可以添加一个校验到我们的record:

[source,scala]
------------------------------------------------------------------------
 class Planet extends Record[Planet] with KeyedRecord[Long]   {
    override def meta = Planet
    override val idField = new LongField(this)

    val name = new StringField(this, 256) {
      override def validations =
        valMinLen(5, "Name too short") _ :: super.validations
    }

  }
------------------------------------------------------------------------

为了检查校验, 我在我们的代码片段中, 我们调用 `validate`, 它将返回record所有的错误:

[source,scala]
---------------------------------------------------------
package code
package snippet

import net.liftweb.http.{S,SHtml}
import net.liftweb.util.Helpers._

import model.MySchema._

class ValidateSnippet {

  def render = {

    val newPlanet = Planet.createRecord

    def validateAndSave() : Unit = newPlanet.validate match {
      case Nil =>
        planets.insert(newPlanet)
        S.notice("Planet '%s' saved" format newPlanet.name.is)

      case errors =>
        S.error(errors)
    }

    "#planetName" #> newPlanet.name.toForm &
    "type=submit" #> SHtml.onSubmitUnit(validateAndSave)
  }
}
---------------------------------------------------------

当这个代码片段运行时, 我们修饰一个 `Planet.name` 表格并且把它连到一个`validateAndSave` 方法.

如果方法 `validate` 显示没有任何错误(`Nil`), 我们存储结果, 并且提示用户.  如果有错误, 我们使用 `S.error` 显示错误.

相关的模板是:

[source,html]
-----------------------------------------------------------------------
<html>
<head>
  <title>Planet Name Validation</title>
</head>
<body data-lift-content-id="main">
<div id="main" data-lift="surround?with=default;at=content">
  <h1>Add a planet</h1>

  <div data-lift="Msgs?showAll=false">
    <lift:notice_class>noticeBox</lift:notice_class>
  </div>

  <p>
    Planet names need to be at least 5 characters long.
  </p>

  <form class="ValidateSnippet?form">

    <div>
      <label for="planetName">Planet name:</label>
      <input id="planetName" type="text"></input>
      <span data-lift="Msg?id=name_id&errorClass=error">
        Msg to appear here
      </span>
    </div>

    <input type="submit"></input>

  </form>

</div>
</body>
</html>
-----------------------------------------------------------------------

在这个模板中, 错误信息显示在 `input` 域的下边, 包含一个CSS类名为 `errorClass`. 成功的信息显示在头部, 在 `<h1>` 标签附近, 使用了一个CSS名为 `noticeBox`.

Discussion
^^^^^^^^^^

内建的验证有:

* `valMinLen` -- 验证一个string, 是否有和给的数字一样的长度.
* `valMaxLen` -- 验证一个string, 是否超过给的数字的长度.
* `valRegex` -- 验证一个string, 是否符合表达式.

一个关于正则表达式验证的例子:

[source,scala]
------------------------------------------------------------
import java.util.regex.Pattern

val url = new StringField(this, 1024) {
  override def validations =
    valRegex( Pattern.compile("^https?://.*"),
              "URLs should start http:// or https://") _ ::
    super.validations
}
------------------------------------------------------------

`validate` 方法返回的错误是一个列表, 类行为 `List[FieldError]`. 方法 `S.error` 接受这个列表, 并且注册每一个验证错误, 所以它可以用来显示错误的内容在页面上. 它是通过分配给一个field一个ID, 然后允许你找到只关于这个域的错误信息, 就像我们这章介绍的一样. ID是存储在域上的, 并且在 `Planet.name` 上, 你可以使用 `Planet.name.uniqueFieldId` 访问ID, 它就是我们使用的 `name_id` .我们使用 `lift:Msg?id=name_id&errorClass=error` 来修饰这个域, 并且显示它的错误.
 
你不是必需使用 `S.error` 来显示一个校验信息.  你可以使用自己的显示代码来直接使用 `FieldError`. 就像你看到 `FieldError` 的源代码一样, 错误是在一个 `msg` 里的:

[source,scala]
------------------------------------------------------------
case class FieldError(field: FieldIdentifier, msg: NodeSeq) {
  override def toString = field.uniqueFieldId + " : " + msg
}
------------------------------------------------------------


See Also
^^^^^^^^

Lift中的 `BaseField.scala` 类包含了内建的 `StringValidators`. 你可以在以下地方找到它: https://github.com/lift/framework/blob/master/core/util/src/main/scala/net/liftweb/util/BaseField.scala[https://github.com/lift/framework/blob/master/core/util/src/main/scala/net/liftweb/util/BaseField.scala].

<<Forms>> 介绍了表单的处理, 提示和错误.



[[CustomValidation]]
自定义校验逻辑
~~~~~~~~~~~~~~

Problem
^^^^^^^

你想自定义一个校验逻辑, 并且应用它在你的record中.

Solution
^^^^^^^^

实现一个方法从域的类型到 `List[FieldError]`, 并且在 `validations` 中引用它.

这里有一个例子: 我们有一个包含星球的数据库, 并且当一个用户输入一个新的星球时, 我们想要这个名字是唯一的. 星球的名字时一个 `String` , 所以为需要提供一个方法 `String => List[FieldError]` . 

通过使用我们的校验方法, (`valUnique`, 下面), 我们包含它在 `validations` 在域 `name` 上:

[source,scala]
-------------------------------------------------------------------------
import net.liftweb.util.FieldError

class Planet extends Record[Planet] with KeyedRecord[Long] {
  override def meta = Planet
  override val idField = new LongField(this)

  val name = new StringField(this, 256) {
    override def validations =
      valUnique("Planet already exists") _ ::
      super.validations
  }

  private def valUnique(errorMsg: => String)(name: String): List[FieldError] =
    Planet.unique_?(name) match {
      case true => FieldError(this.name, errorMsg) :: Nil
      case false => Nil
    }
}

object Planet extends Planet with MetaRecord[Planet] {
  def unique_?(name: String) = from(planets) { p =>
    where(lower(p.name) === lower(name)) select(p)
  }.isEmpty
}
-------------------------------------------------------------------------

这个校验被触发就像其他的 <<FieldValidation>> 的校验一样.

Discussion
^^^^^^^^^^

一个校验方法有两部分组成:一个错误返回信息和一个待校验值.这允许你很简单的重用在其他域上. 比如说, 如果你想检验一个卫星有一个唯一的名字, 你可以用完全一样的方法, 只是提供一个不同的错误信息.

方法 `FieldError` 中, 你的返回需要知道它的域和返回的信息. 在这个例子中是 `name`, 但是我们使用 `this.name` 来避免与 `name` 参数产生歧义. `name` 是一个放入 `valUnique` 方法的参数.

这个例子使用的是一个文本作为返回的错误信息, 你同样可以使用 `FieldError` 的变形来接受一个 `NodeSeq`.  这样做可以人那个你的程序更加安全.  比如说:

[source,scala]
-------------------------------------------------------------------------
FieldError(this.name, <p>Please see <a href="/policy">our name policy</a></p>)
-------------------------------------------------------------------------

为了国际化, 你也许更希望传递一个key到校验方法, 并且使用 `S.?`:

[source,scala]
-------------------------------------------------------------------------
val name = new StringField(this, 256) {
    override def validations =
      valUnique("validation.planet") _ ::
      super.validations
  }

// ...combined with...

private def valUnique(errorKey: => String)(name: String): List[FieldError] =
  Planet.unique_?(name) match {
    case false => FieldError(this.name, S ? errorKey) :: Nil
    case true => Nil
  }
-------------------------------------------------------------------------


See Also
^^^^^^^^

<<FieldValidation>> 介绍了域校验和内建校验.

文本本地化在以下地址有讨论: https://www.assembla.com/wiki/show/liftweb/Localization[https://www.assembla.com/wiki/show/liftweb/Localization].


[[SquerylFilter]]
在它成为一个Set前, 修改一个域的值
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Problem
^^^^^^^

你想修改一个域的值, 所以你模型里的值是修改以后的版本, 比如说, 清理一个值, 通过删除前边或者后边的空白.

Solution
^^^^^^^^

重写 `setFilter` 并且在一个域上, 提供一个方法的列表.

为了删除用户输入的开头和结尾的空白, 这个域将使用 `trim` 过滤器:

[source,scala]
-----------------------------------------------------
val name = new StringField(this, 256) {
   override def setFilter = trim _ :: super.setFilter
}
-----------------------------------------------------

Discussion
^^^^^^^^^^

一些内建的过滤器有:

* `crop` -- 通过切断, 确定域的最大和最小长度.
* `trim` -- 使用 `String.trim` 在域的值上.
* `toUpper` 和 `toLower` -- 改变域的大小写.
* `removeRegExChars` -- 删除匹配的正则表达式的字符.
* `notNull` -- 替换null为空白字符串.



一个对于 `String` 域的过滤器, 将会是一个为 `String => String`, 的类型, 并且 `setFilter` 方法需要一个 `List`. 知道了这个以后, 写一个过滤器就变得很直接. 比如说, 以下是一个过滤器, 它有一个简单的表格在我们的域 `name` 上:

[source,scala]
-----------------------------------------------------
 def titleCase(in: String) =
  in.split("\\s").
  map(_.toList).
  collect {
    case x :: xs  => (Character.toUpperCase(x).toString :: xs).mkString
  }.mkString(" ")
-----------------------------------------------------

这个方法是分割一个有空格的字符串, 转化它们到一个字符的列表, 把第一个字符变成大写, 然后把其他字符放回到原位.

然后我们把他安装到过滤器...

[source,scala]
-----------------------------------------------------
val name = new StringField(this, 256) {
   override def setFilter =
    trim _ :: titleCase _ :: super.setFilter
}
-----------------------------------------------------

...当用户输入 "jaglan beta" 作为一个星球名字的时候, 在数据库中, 我们看到的是 "Jaglan Beta".


See Also
^^^^^^^^

Trait是最好理解一个狗氯气的地方 `StringValidators` 在源代码 `BaseField` 中: https://github.com/lift/framework/blob/master/core/util/src/main/scala/net/liftweb/util/BaseField.scala[https://github.com/lift/framework/blob/master/core/util/src/main/scala/net/liftweb/util/BaseField.scala].

如果你真的很想做一个title case, 那么Apache Commons中有一个类为 `WordUtils`.  请见: http://commons.apache.org/lang/[http://commons.apache.org/lang/].


[[SquerylUnitTest]]
使用Specs2测试
~~~~~~~~~~~~~

Problem
^^^^^^^

你想写一个Specs2测试对于你的Squeryl 和 Record的数据库中.

Solution
^^^^^^^^

使用一个内存数据库, 并且分配它作为你的测试数据库.

实现它需要三步:包含一个数据库在你的工程中, 并且把他设置成一个内存数据库. 建立一个可重用的trait来设置数据库. 使用这个trait在你的测试中.

H2数据库有一个内存模式, 这意味着它将不会保存数据到硬盘. 它需要被设置在 `build.sbt` 作为一个依赖库. 同时, 你需要修改 `build.sbt`, 并且取消SBT的同步调试功能来防止测试数据库和生产数据库互相影响:

[source, scala]
--------------------------------------------
libraryDependencies += "com.h2database" % "h2" % "1.3.170"

parallelExecution in Test := false
--------------------------------------------

建立一个trait来初始化数据库并且建立一个机制:

[source, scala]
--------------------------------------------
package code.model

import java.sql.DriverManager

import org.squeryl.Session
import org.squeryl.adapters.H2Adapter

import net.liftweb.util.StringHelpers
import net.liftweb.common._
import net.liftweb.http.{S, Req, LiftSession }
import net.liftweb.squerylrecord.SquerylRecord
import net.liftweb.squerylrecord.RecordTypeMode._

import org.specs2.mutable.Around
import org.specs2.execute.Result

trait TestLiftSession {
  def session = new LiftSession("", StringHelpers.randomString(20), Empty)
  def inSession[T](a: => T): T = S.init(Req.nil, session) { a }
}

trait DBTestKit extends Loggable {

  Class.forName("org.h2.Driver")

  Logger.setup = Full(net.liftweb.util.LoggingAutoConfigurer())
  Logger.setup.foreach { _.apply() }

  def configureH2() = {
    SquerylRecord.initWithSquerylSession(
      Session.create(
        DriverManager.getConnection("jdbc:h2:mem:dbname;DB_CLOSE_DELAY=-1", "sa", ""),
        new H2Adapter)
    )
  }

  def createDb() {
    inTransaction {
      try {
        MySchema.drop
        MySchema.create
      } catch {
        case e : Throwable =>
          logger.error("DB Schema error", e)
          throw e
      }
    }
  }

}

case class InMemoryDB() extends Around with DBTestKit with TestLiftSession {
  def around[T <% Result](testToRun: =>T) = {
    configureH2
    createDb
    inSession {
      inTransaction {
        testToRun
      }
    }
  }
}
--------------------------------------------

总结一下, 这个trait为Specs2提供一个 `InMemoryDB` _context_ . 它确保了数据库被设置, 并且机制建立了一个transaction在你的测试中.

最后, 混入这个trait到你的测试中, 并且执行它的 `InMemoryDB`.

作为一个例子, 我们使用 <<SquerylOneToMany>> 的机制, 我们测试Mars有两个月亮:

[source, scala]
--------------------------------------------
package code.model

import org.specs2.mutable._
import net.liftweb.squerylrecord.RecordTypeMode._
import MySchema._

class PlanetsSpec extends Specification with DBTestKit {

  sequential

  "Planets" >> {

    "know that Mars has two moons" >> InMemoryDB() {

      val mars = planets.insert(Planet.createRecord.name("Mars"))
      Satellite.createRecord.name("Phobos").planetId(mars.idField.is).save
      Satellite.createRecord.name("Deimos").planetId(mars.idField.is).save

      mars.satellites.size must_== 2
    }

  }

}
--------------------------------------------

使用SBT的 `test` 来运行这个, 将会出现一个成功的信息:

------------------------------------------
> test
[info] PlanetsSpec
[info]
[info] Planets
[info] + know that Mars has two moons
[info]
[info]
[info] Total for specification PlanetsSpec
[info] Finished in 1 second, 274 ms
[info] 1 example, 0 failure, 0 error
[info]
[info] Passed: : Total 1, Failed 0, Errors 0, Passed 1, Skipped 0
[success] Total time: 3 s, completed 03-Feb-2013 11:31:16
------------------------------------------


Discussion
^^^^^^^^^^

`DBTestKit` trait 为我们做了很多工作. 在最底层, 它加载了H2的驱动, 并且设置了Squeryl连接到一个内存模式. JDBC的 `mem` 部分(`jdbc:h2:mem:dbname;DB_CLOSE_DELAY=-1`) 意味着H2将不会把数据保存在本地磁盘.  数据库在内存中, 确保了没有文件在硬盘中维护, 并且它运行的很快.

默认下, 当一个连接被关闭, 内存的数据库会被摧毁. 在这里, 我们取消这个操作, 通过添加 `DB_CLOSE_DELAY=-1` , 它将允许我们写多连接的测试.

连接管理的下一步是建立一个数据库的机制在内存中. 我们在 `createDb` 中通过扔掉机制, 并且任何数据当我们重新启动时, 都是新的. 如果你有一个十分普通的数据库测试数据, 这将会是一个非常好的地方在测试运行前, 插入数据.

以上几部在 `InMemoryDB` 类中汇集, 它是一个Specs2接口来运行 `Around` 测试.  我们还包裹一个测试在 `TestLiftSession` 中. 它会建立一个空白的会话, 这将会对你进行的关于状态的测试有帮助 (比如说 `S` 对象). 但是它不是运行测试所必需的, 不过还是希望你把它包含在这里, 因为你将会在某时用到它.

在我们的设置中, 我们融合了 `DBTestKit` 和引用了 `InMemoryDB` 在测试中, 来访问数据库. 你也许会发现, 我们使用 `>>` 而不是Specs2中的 `should` 和 `in`. 这是因为我们避免了Squeryl和Specs2的方法名字的重复.

就像我们取消了同步执行在SBT中, 我们也需要取消同步执行在Specs2中 通过使用 `sequential` . 我们这样做是为了防止一个情况: 一个测试也许需要一个数据, 这个数据正在被另一个测试修改.

如果所有的测试在同一个配置中将使用数据库, 你可以使用Specs2中的 `AroundContextExample[T]` 来避免使用 `InMemoryDB` 在每个测试中.为了实现它, 掺入 `AroundContextExample[InMemoryDB]` 并且定义 `aroundContext`:

[source, scala]
--------------------------------------------
package code.model

import MySchema._

import org.specs2.mutable._
import org.specs2.specification.AroundContextExample
import net.liftweb.squerylrecord.RecordTypeMode._

class AlternativePlanetsSpec extends Specification with
  AroundContextExample[InMemoryDB] {

  sequential

  def aroundContext = new InMemoryDB()

  "Solar System" >> {

    "know that Mars has two moons" >> {

      val mars = planets.insert(Planet.createRecord.name("Mars"))
      Satellite.createRecord.name("Phobos").planetId(mars.idField.is).save
      Satellite.createRecord.name("Deimos").planetId(mars.idField.is).save

      mars.satellites.size must_== 2
    }
  }
}
--------------------------------------------

所有的测试在 `AlternativePlanetsSpec` 中将含有 `InMemoryDB` .

我们使用了一个内存数据库, 因为我们需要它的速度和无磁盘文件. 然而, 你可以用自己的数据库: 你需要改变驱动和连接.

See Also
^^^^^^^^

请见 http://www.h2database.com/html/features.html#in_memory_databases[http://www.h2database.com/html/features.html#in_memory_databases] 里有更多关于H2数据库的设置文档.

<<MongoUnitTest>> 中讨论了在MongoDB下的测试, 并且在里面SBT的其他测试命令在这里也同样适用.


[[RandomValueColumn]]
存储一个随机值到列中
~~~~~~~~~~~~~~~~~~~

Problem
^^^^^^^

你需要一个列中有随机的值.

Solution
^^^^^^^^

使用 `UniqueIdField`:

[source,scala]
--------------------------------------------
import net.liftweb.record.field.UniqueIdField
val randomId = new UniqueIdField(this, 32) {}
--------------------------------------------

请注意, `{}` 在这里是必需的, `UniqueIdField` 是一个抽象类.

32是表示生成随机值的位数.

Discussion
^^^^^^^^^^

`UniqueIdField` 域是一类 `StringField` 并且它默认的值是来自 `StringHelpers.randomString`. 值是随机生成的, 但是不能确保是唯一的在数据库里.

在 `UniqueIdField` 下生成的数据库语句为 `varchar(32) not null`或者类似的语句, 它们的值是:

----------------------
GOJFGQRLS5GVYGPH3L3HRNXTATG3RM5M
----------------------

就像你看到的一样, 值只是由数字和字母组成, 这使得它很适用于URL中. 比如说, 在 `ProtoUser`中, 你想生成一个唯一的link, 使得用户在email中, 可以使用它来验证用户的账户.

如果你需要改变这个值, 使用 `reset` 方法在域上将会生成一个随机的新的值.

如果你需要一个自动的值, 特别是每行一个的唯一值, 你可以给你的域包裹一个 _universally unique identifier_ (UUID):

[source,scala]
--------------------------------------------
import java.util.UUID

val uuid = new StringField(this, 36) {
  override def defaultValue = UUID.randomUUID().toString
}
--------------------------------------------

这将会自动插入值到表格"6481a844-460a-a4e0-9191-c808e3051519"中, 在你的数据库里.



See Also
^^^^^^^^

Java的UUID在以下有介绍: http://docs.oracle.com/javase/7/docs/api/java/util/UUID.html[http://docs.oracle.com/javase/7/docs/api/java/util/UUID.html] 里面有一个讲述RFC 4122的文档.





[[SquerylUpdatedCreated]]
自动生成和更新的时间标签
~~~~~~~~~~~~~~~~~~~~~~

Problem
^^^^^^^

你想建立并且更新时间标签在你的record上, 并且希望它们自动更新, 当移行添加或者更新时.

Solution
^^^^^^^^

定义以下的traits:

[source,scala]
--------------------------------------------------------------
package code.model

import java.util.Calendar

import net.liftweb.record.field.DateTimeField
import net.liftweb.record.Record

trait Created[T <: Created[T]] extends Record[T] {
  self: T =>
  val created: DateTimeField[T] = new DateTimeField(this) {
    override def defaultValue = Calendar.getInstance
  }
}

trait Updated[T <: Updated[T]] extends Record[T] {
  self: T =>

  val updated = new DateTimeField(this) {
    override def defaultValue = Calendar.getInstance
  }

  def onUpdate = this.updated(Calendar.getInstance)

}

trait CreatedUpdated[T <: Updated[T] with Created[T]] extends
  Updated[T] with Created[T] {
    self: T =>
}
--------------------------------------------------------------

添加这个traits到你的模型中. 比如说, 我们修改 `Planet` record 中包含自动更新和创建的时间:

[source,scala]
----------------------------------------------------------
class Planet private () extends Record[Planet]
  with KeyedRecord[Long] with CreatedUpdated[Planet] {
    override def meta = Planet
    // field entries as normal...
}
----------------------------------------------------------

最后, 分配 `updated` 域:

[source,scala]
-----------------------------------------------
class MySchema extends Schema {
  ...
  override def callbacks = Seq(
    beforeUpdate[Planet] call {_.onUpdate}
  )
  ...
-----------------------------------------------

Discussion
^^^^^^^^^^

尽管在 `net.liftweb.record.LifecycleCallbacks` trait 中有一个build可以让你触发onUpdate, afterDelete 等等, 它们只能用在单一的域上, 而不是所有的records. 我们的目标是当Record更新时, 更新每一个域, 所以在这里我们不能使用`LiftcycleCallbacks`.

`CreatedUpdated` trait简单的添加了一个 `updated` 和 `created` 域到一个record, 但是我们必需要记住添加一个挂钩到机制中来确保 `updated` 的值, 当我们改变一个record的时候, 改变.

我们需要在机制中添加的`CreatedUpdated` 需要包含以下两行:

[source,sql]
-----------------------------------------------
updated timestamp not null,
created timestamp not null
-----------------------------------------------

`timestamp` 是给H2数据库用的. 对于其他数据库, 会不同.

这个值可以被访问就像其他的值一样 <<SquerylOneToMany>> 我们可以运行以下语句:

[source,scala]
-----------------------------------------------
val updated : Calendar = mars.updated.id
val created : Calendar = mars.created.is
-----------------------------------------------

如果你只想要created time, updated time, 只需要混入 `Created[T]` 或者 `Updaed[T]` trait 而不是 `CreatedUpdated[T]`.

这里应该知道的时, `onUpdate` 只在全部更新的时候才会被调用, 并且不能被Squeryl的部分更新调用. 一个全部更新是指当一个对象被声明, 并且存储时. 一个部分更新是指你尝试声明很多对象通过一条语句.

如果你对其他的Record自动化感兴趣, Squeryl的callback机制也支持其他的触发行为:

* `beforeInsert` 和 `afterInsert`
* `afterSelect`
* `beforeUpdate` 和 `afterUpdate`
* `beforeDelete` 和 `afterDelete`

See Also
^^^^^^^^

以下是一个关于部分更新和全部更新的讨论: http://squeryl.org/inserts-updates-delete.html[http://squeryl.org/inserts-updates-delete.html].


[[SquerylLogging]]
SQL日志
~~~~~~

Problem
^^^^^^^

你想看Squeryl是如何执行SQL的.

Solution
^^^^^^^^

添加以下语句在你有一个Squeryl会话时, 比如, 在你的语句前:

[source,scala]
---------------------------------------------------------------
org.squeryl.Session.currentSession.setLogger( s => println(s) )
---------------------------------------------------------------

通过提供一个 `String => Unit` 方法到 `setLogger`, Squeryl 将会执行这个方法, 当SQL运行时. 在这个例子中, 我们只是简单的把输出打印到console.

Discussion
^^^^^^^^^^

你也许希望使用日志机制在Lift中捕获SQL语句, 比如说:

[source,scala]
---------------------------------------------------------------
package code.snippet

import net.liftweb.common.Loggable
import org.squeryl.Session

class MySnippet extends Loggable {

  def render = {
    Session.currentSession.setLogger( s => logger.info(s) )
    // ...your snippet code here...
  }
}
---------------------------------------------------------------

以上代码会根据日志系统的设置来记录语句的日志, 你只需要设置 `src/resources/props/default.logback.xml` 文件.

也许设置每个代码片段的日志非常不方便. 如果你想触发日志在所有的代码片段上, 你可以修改 `addAround` 方法在 `Boot.scala` 中.

请回忆以下, 在 <<ConfiguringSqueryl>> 中, 我们是这样定义的:

[source,scala]
---------------------------------------------------------------
S.addAround(new LoanWrapper {
  override def apply[T](f: => T): T = inTransaction { f }
})
---------------------------------------------------------------

为了开启日志在每个会话中, 我们可以修改 `Boot.scala` 来混入日志系统, 并且开启日志:

[source,scala]
---------------------------------------------------------------
class Boot extends Loggable {

  // ...boot as usual here...

  S.addAround(new LoanWrapper {
    override def apply[T](f: => T): T = inTransaction {
      Session.currentSession.setLogger( s => logger.info(s) )
      f
    }
  })

}
---------------------------------------------------------------


See Also
^^^^^^^^

Squeryl 的 `setLogger` 在下面的地址有文档: http://squeryl.org/miscellaneous.html[http://squeryl.org/miscellaneous.html].

你可以学到更多关于Lift的日志在Lift Wiki: https://www.assembla.com/spaces/liftweb/wiki/Logging[https://www.assembla.com/spaces/liftweb/wiki/Logging].






[[SquerylMediumText]]
使用MySQL MEDIUMTEXT
~~~~~~~~~~~~~~~~~~~

Problem
^^^^^^^

你想使用MySQL的 `MEDIUMTEXT` 在一个列上, 但是 `StringField`
没有这个选项.

Solution
^^^^^^^^

使用Squeryl的 `dbType` 在你的机制中:

[source,scala]
------------------------------------------
object MySchema extends Schema {
  on(mytable)(t => declare(
    t.mycolumn defineAs dbType("MEDIUMTEXT")
  ))
}
------------------------------------------

这个机制设置会给你一个正确的列类型在MySQL中:

[source,sql]
--------------------------------
create table mytable (
    mycolumn MEDIUMTEXT not null
);
--------------------------------

在Record中, 你可以想平常一样使用 `StringField`.

Discussion
^^^^^^^^^^

这章涉及了Squeryl的机制设置的灵活性和DSL. 这里的列设置是很多个你可以自行调整的设置之一.

比如说, 你可以使用语句来连锁一个列属性对于一个单一的列, 并且定义很多个列在同一时间:

[source,scala]
------------------------------------------
object MySchema extends Schema {
  on(mytable)(t => declare(
    t.mycolumn defineAs(dbType("MEDIUMTEXT"),indexed),
    t.id definedAs(unique, named("MY_ID"))
  ))
}
------------------------------------------


See Also
^^^^^^^^

机制定义页面给你很多可以选择自定义的关于表和列属性:: http://squeryl.org/schema-definition.html[http://squeryl.org/schema-definition.html].




[[MySQLCharSet]]
MySQL编码
~~~~~~~~~

Problem
^^^^^^^

一些存储在MySQL数据库的数据显示为 `???`.

Solution
^^^^^^^^

请确保:

* `LiftRules.early.append(_.setCharacterEncoding("UTF-8"))` 在 `Boot.scala` 中.
* `?useUnicode=true&characterEncoding=UTF-8` 在你的数据库连接中.
* 你的数据库使用UTF-8编码建立.

Discussion
^^^^^^^^^^

这里有很多的互相环节, 它们会影响字符的编码, 一个MySQL数据库, 基本的问题是, 数据的传输在网络之间没有任何意义, 除非你能知道它的编码.

`setCharacterEncoding("UTF-8")` 在 `Boot.scala` 被调用在每一个 `HTTPRequest` , 在一个容器中 , 它作用在 `ServletRequest`. 这就是为什么一个请求的参数会被分析, 当一个容器收到这个请求时.

与它相反的是, 一个由Lift发出的回复会被用UTF-8编码, 你会在很多地方看到这个设置.
比如说, `templates-hidden/default` 包含:

[source, html]
-------------------------------------------
<meta http-equiv="content-type" content="text/html; charset=UTF-8" />
-------------------------------------------

并且, `LiftResponse` 设置为UTF-8编码.

另一个需要关注的是, 字符数据如何从Lift通过网络发送到数据库. 这是被JDBC驱动的参数控制的. 默认的MySQL会查看参数上的编码, 然后自动应用它. 在这里, 我们强制用UTF-8.

最后, MySQL数据库自己需要被设置成存储数据的编码为UTF-8. 默认的设置不是UTF-8, 所以当你创建数据库的时候, 你需要强制数据库为UTF-8.

[source, sql]
-------------------------------------------
CREATE DATABASE myDb CHARACTER SET utf8
-------------------------------------------

See Also
^^^^^^^^

MySQL JDBC设置在: http://dev.mysql.com/doc/refman/5.6/en/connector-j-reference-configuration-properties.html[http://dev.mysql.com/doc/refman/5.6/en/connector-j-reference-configuration-properties.html].




